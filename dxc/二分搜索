 6.2 局部最小值位置练习题
 定义局部最小的概念。arr长度为1时，arr[0]是局部最小。arr的长度为N(N>1)时，如果arr[0]<arr[1]，那么arr[0]是局部最小；如果arr[N-1]<arr[N-2]，那么arr[N-1]是局部最小；如果0<i<N-1，既有arr[i]<arr[i-1]又有arr[i]<arr[i+1]，那么arr[i]是局部最小。 给定无序数组arr，已知arr中任意两个相邻的数都不相等，写一个函数，只需返回arr中任意一个局部最小出现的位置即可。
 
 import java.util.*;
    
public class Solution {
    public int getLessIndex(int[] arr) {
        if (arr == null || arr.length == 0) {
            return -1;//要考虑下，应该返回什么，我当时抛出了个异常
        }
		      return getLessIndex(arr, 0, arr.length);
    }
    
    public int getLessIndex(int[] arr, int begin, int end) {//begin包含，end不包含
        if (end - begin == 1) {
            return begin;//还有注意是找位置，还是对应的值
        }
        if (arr[begin] < arr[begin+1]) {
            return begin;
        }
        if (arr[end-1] < arr[end-2]) {
            return end-1;
        }
        int middle = (end - begin) / 2;//走到这里n至少是3
        if (arr[middle] < arr[middle-1] && arr[middle] < arr[middle+1]){
            return middle;
        } else if (arr[middle] > arr[middle-1] && arr[middle] < arr[middle+1]) {
            return getLessIndex(arr, begin+1, middle);
        } else {
            return getLessIndex(arr, middle+1, end-1);
        }
    }
}

6.3 元素最左出现练习题
对于一个有序数组arr，再给定一个整数num，请在arr中找到num这个数出现的最左边的位置。
给定一个数组arr及它的大小n，同时给定num。请返回所求位置。若该元素在数组中未出现，请返回-1。
测试样例：
[1,2,3,3,4],5,3
返回：2

import java.util.*;

public class LeftMostAppearance {
    public int findPos(int[] arr, int n, int num) {
        // write code here
        if (arr == null || arr.length != n || n <= 0) {
            return -1;
        }
        if (n == 1) {
            if (arr[0] == num) {
                return 0;
            } else {
                return -1;
            }
        }
        return findPos(arr, num, 0, n);
    }
    
    public int findPos(int[] arr, int num, int begin, int end) {//begin包含，end不包含
        if (begin >= end) {//这种移下标的，一定要把所有的情况都处理了，保不重就出现这种情况了。（错误1）
    		return -1;
    	}
        
        if (end - begin == 1) {
            if (arr[begin] == num) {
                return begin;
            } else {
                return -1;
            }
        }
        int prePos = -1;
        int aftPos = -1;
        int middle = (end - begin) / 2 + begin;
        if (arr[begin] > arr[end-1]) {//递减数组
            if (arr[middle] > num) {
                return findPos(arr, num, middle+1, end);
            } else if (arr[middle] < num) {
                return findPos(arr, num, begin, middle);
            } else {
                prePos = middle;
                aftPos = findPos(arr, num, begin, middle);
                if (aftPos != -1) {
                    return aftPos;
                } else {
                    return prePos;
                }
            }
        } else if (arr[begin] < arr[end-1]) {//递增数组
            if (arr[middle] > num) {
                return findPos(arr, num, begin, middle);
            } else if(arr[middle] < num) {
                return findPos(arr, num, middle+1, end);
            } else {
                prePos = middle;
                aftPos = findPos(arr, num, begin, middle);
                if (aftPos != -1) {
                    return aftPos;
                } else {
                    return prePos;
                }
            }
        } else {
            if (arr[begin] != num) {
                return -1;
            } else {
                return begin;
            }
        }
    }
}

 6.4 循环有序数组最小值练习题
 对于一个有序循环数组arr，返回arr中的最小值。有序循环数组是指，有序数组左边任意长度的部分放到右边去，右边的部分拿到左边来。比如数组[1,2,3,3,4]，是有序循环数组，[4,1,2,3,3]也是。
给定数组arr及它的大小n，请返回最小值。
测试样例：
[4,1,2,3,3],5
返回：1

import java.util.*;

public class MinValue {
    public int getMin(int[] arr, int n) {
        // write code here
    }
}

6.6 最左原位
有一个有序数组arr，其中不含有重复元素，请找到满足arr[i]==i条件的最左的位置。如果所有位置上的数都不满足条件，返回-1。
给定有序数组arr及它的大小n，请返回所求值。
测试样例：
[-1,0,2,3],4
返回：2

import java.util.*;

public class Find {
    public int findPos(int[] arr, int n) {
        // write code here
        if (arr == null || arr.length != n || n<= 0) {
            return -1;
        }
        if (n == 1) {
            if (arr[0] == 0) {
                return 0;
            } else {
                return -1;
            }
        }
        return findPos(arr, 0, n);
    }
    
    public int findPos(int[] arr, int begin, int end) {//begin包括，end不包括
        if (begin >= end) {
            return -1;
        }
        if (end - begin == 1) {
            if (arr[begin] == begin) {
                return begin;
            } else {
                return -1;
            }
        }
        int middle = (end - begin) / 2 + begin;
        int prePos = -1;
        if (arr[begin] < arr[end-1]) {//递增数组
            if (arr[end-1] <= 0) {
                return -1;
            }
            if (arr[middle] < middle) {
                return findPos(arr, middle+1, end);
            } else if (arr[middle] > middle) {
                return findPos(arr, begin, middle);
            } else {
                prePos = findPos(arr, begin, middle);
                if (prePos == -1) {
                    return middle;
                } else {
                    return prePos;
                }
            }
        } else {//递减数组
            if (arr[0] < 0) {
                return -1;
            }
            if (arr[middle] < middle) {
                return findPos(arr, begin, middle);
            } else if (arr[middle] > middle) {
                return findPos(arr, middle+1, end);
            } else {
                return middle;
            }
        }
    }
}


 6.7 完全二叉树计数练习题
 给定一棵完全二叉树的根节点root，返回这棵树的节点个数。如果完全二叉树的节点数为N，请实现时间复杂度低于O(N)的解法。
给定树的根结点root，请返回树的大小。

import java.util.*;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}*/
public class CountNodes {
    public int count(TreeNode root) {
        // write code here
    }
}

6.8 快速N次方练习题
如果更快的求一个整数k的n次方。如果两个整数相乘并得到结果的时间复杂度为O(1)，得到整数k的N次方的过程请实现时间复杂度为O(logN)的方法。
给定k和n，请返回k的n次方，为了防止溢出，请返回结果Mod 1000000007的值。
测试样例：
2,3
返回：8

心得：
在算有可能溢出的值得乘积时：先转换成long值，乘，再取模，再转换成int
bin[i] = (int)(((long)bin[i-1] * (long)bin[i-1]) % 1000000007);

方法1.
import java.util.*;

public class QuickPower {
    public int getPower(int k, int N) {//就是很纯的递归，别用老师讲的先算二进制序列，再算，各种问题
        // write code here
        if (N < 0 || k == 0) {
            return -1;
        }
        if (N == 0) {
            return 1;
        }
        if (N == 1) {
            return k;
        }
        if (N % 2 == 0) {
            int tmp = getPower(k, N/2);
            long temp = (long)tmp;
            temp = (temp * temp) % 1000000007;
            return (int)(temp);
        } else {
            int tmp = getPower(k, (N-1)/2);
            long temp = (long)tmp;
            temp = (temp * temp) % 1000000007;
            return (int)((temp * k) % 1000000007);
        }
    }
}

方法2：老师讲的先找二进制序列
import java.util.*;

public class QuickPower {
    public static int getPower(int k, int N) {
        // write code here
        if (N < 0 || k == 0) {
            return -1;
        }
        if (N == 0) {
            return 1;
        }
        if (N == 1) {
            return k;
        }
        String sri = getBinSri(N);//获取N对应的二进制序列
        int len = sri.length();
        int[] bin = new int[len];//获取2的n次方
        bin[0] = k;
        for (int i=1; i<len; i++) {
            bin[i] = (int)(((long)bin[i-1] * (long)bin[i-1]) % 1000000007);
            System.out.println(bin[i]);
        }
        int result = 1;
        for (int i=0; i<len; i++) {
            if (sri.charAt(i) == '1') {
                result = (int)(((long)result * (long)bin[len - 1 - i]) % 1000000007);
            } else {
                result = result * 1;
            }
        }
        return (int)(result % 1000000007);
    }
    
    public static String getBinSri(int n) {
        if (n == 1) {
            return Integer.toString(1);
        }
        int x = n / 2;//商
        String y = Integer.toString(n % 2);//余数
        String result = getBinSri(x);
        return result + y;
        
    }
}
