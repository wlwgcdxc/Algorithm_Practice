4.2 可查询最值的栈练习题
定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。
import java.util.Stack;

public class Solution {
    
    private Stack<Integer> dataStack = new Stack<Integer>();//通常意义上的栈，泛型需要是个引用（错误1）
    private Stack<Integer> minStack = new Stack<Integer>();//存放datastack上对应位置的最小值
    
    public void push(int node) {
    	if (dataStack.empty()) {           
            minStack.push(node);
        } else {
            if (node < minStack.peek()) {
                minStack.push(node);
            } else {
                minStack.push(minStack.peek());
            }
        }
        dataStack.push(node);
    }
    
    public void pop() {
        if(dataStack.empty()) {
            throw new RuntimeException("Your stack is empty");//这种不正常的情况还是抛出异常比较好（错误二）
        } else {
            dataStack.pop();
            minStack.pop();
        }
    }
    
    public int top() {
        if (dataStack.empty()) {
            throw new RuntimeException("Your stack is empty");
        } else {
            return dataStack.peek();//忘记return了（错误三）
        }
    }
    
    public int min() {
        if (dataStack.empty()) {
            throw new RuntimeException("Your stack is empty");
        } else {
            return minStack.peek();
        }
    }
}

4.4 双栈队列练习题
编写一个类,只能用两个栈结构实现队列,支持队列的基本操作(push，pop)。
给定一个操作序列ope及它的长度n，其中元素为正数代表push操作，为0代表pop操作，保证操作序列合法且一定含pop操作，请返回pop的结果序列。
测试样例：
[1,2,3,0,4,0],6
返回：[1,2]

import java.util.*;

public class TwoStack {

    private Stack<Integer> inStack = new Stack<Integer>();
    private Stack<Integer> outStack = new Stack<Integer>();
    
    public int[] twoStack(int[] ope, int n) {
        // write code here
        if (ope.length != n || n <= 0) {
            throw new RuntimeException("input is error.");
        }
        
        List<Integer> list = new LinkedList<Integer>();//存放pop出来的数据
        
        for(int i=0; i<n; i++) {
            if (ope[i] > 0) {
                inStack.push(ope[i]);
            } else {
                if (outStack.empty()) {//要是空的，首先要把入栈队列中的所有数据push进来
                    int tmp;
                    while (!inStack.empty()) {//要一次性的全入栈，不然顺序变了
                        tmp = inStack.pop();
                        outStack.push(tmp);
                    }
                }
                list.add(outStack.pop());//要是不为空，就必须先pop out里的，不然顺序也变了。
            }
        }
        int num = list.size();
        int[] result = new int[num];
        for(int i=0; i<num; i++) {
            result[i] = list.get(i);
        }
        return result;
    }
}
