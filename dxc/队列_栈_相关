4.2 可查询最值的栈练习题
定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。
import java.util.Stack;

public class Solution {
    
    private Stack<Integer> dataStack = new Stack<Integer>();//通常意义上的栈，泛型需要是个引用（错误1）
    private Stack<Integer> minStack = new Stack<Integer>();//存放datastack上对应位置的最小值
    
    public void push(int node) {
    	if (dataStack.empty()) {           
            minStack.push(node);
        } else {
            if (node < minStack.peek()) {
                minStack.push(node);
            } else {
                minStack.push(minStack.peek());
            }
        }
        dataStack.push(node);
    }
    
    public void pop() {
        if(dataStack.empty()) {
            throw new RuntimeException("Your stack is empty");//这种不正常的情况还是抛出异常比较好（错误二）
        } else {
            dataStack.pop();
            minStack.pop();
        }
    }
    
    public int top() {
        if (dataStack.empty()) {
            throw new RuntimeException("Your stack is empty");
        } else {
            return dataStack.peek();//忘记return了（错误三）
        }
    }
    
    public int min() {
        if (dataStack.empty()) {
            throw new RuntimeException("Your stack is empty");
        } else {
            return minStack.peek();
        }
    }
}

4.4 双栈队列练习题
编写一个类,只能用两个栈结构实现队列,支持队列的基本操作(push，pop)。
给定一个操作序列ope及它的长度n，其中元素为正数代表push操作，为0代表pop操作，保证操作序列合法且一定含pop操作，请返回pop的结果序列。
测试样例：
[1,2,3,0,4,0],6
返回：[1,2]

import java.util.*;

public class TwoStack {

    private Stack<Integer> inStack = new Stack<Integer>();
    private Stack<Integer> outStack = new Stack<Integer>();
    
    public int[] twoStack(int[] ope, int n) {
        // write code here
        if (ope.length != n || n <= 0) {
            throw new RuntimeException("input is error.");
        }
        
        List<Integer> list = new LinkedList<Integer>();//存放pop出来的数据
        
        for(int i=0; i<n; i++) {
            if (ope[i] > 0) {
                inStack.push(ope[i]);
            } else {
                if (outStack.empty()) {//要是空的，首先要把入栈队列中的所有数据push进来
                    int tmp;
                    while (!inStack.empty()) {//要一次性的全入栈，不然顺序变了
                        tmp = inStack.pop();
                        outStack.push(tmp);
                    }
                }
                list.add(outStack.pop());//要是不为空，就必须先pop out里的，不然顺序也变了。
            }
        }
        int num = list.size();
        int[] result = new int[num];
        for(int i=0; i<num; i++) {
            result[i] = list.get(i);
        }
        return result;
    }
}

4.5 栈的反转练习题
实现一个栈的逆序，但是只能用递归函数和这个栈本身的pop操作来实现，而不能自己申请另外的数据结构。
给定一个整数数组A即为给定的栈，同时给定它的大小n，请返回逆序后的栈。
测试样例：
[4,3,2,1],4
返回：[1,2,3,4]

import java.util.*;

public class StackReverse {
    
    private Stack<Integer> stack = new Stack<Integer>();
    
    public int[] reverseStack(int[] A, int n) {//感觉题目的意思是从左到右，分别对应栈顶和栈低
        // write code here
        for(int i=A.length-1; i>=0; i--) {
            stack.push(A[i]);
        }
        int[] result = new int[n];
        int k = 0;
        while (!stack.empty()) {
           result[k++] = getEle(stack); 
        } 
        return result;
    }
    
    public int getEle(Stack<Integer> stack) {
    	int tmp = stack.pop();
        if (stack.empty()) {
            return tmp;
        }
        int result = getEle(stack);//拿到子栈最低端的元素
        stack.push(tmp); //并把当前拿到的值，push进栈，保持原有的顺序
        return result;
    }
}
